# 1 "/loongson/ejtag-debug/bin/Eep_8000.c"
# 1 "/loongson/ejtag-debug/bin//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_HOSTED__ 1
#define __GNUC__ 4
#define __GNUC_MINOR__ 4
#define __GNUC_PATCHLEVEL__ 0
#define __SIZE_TYPE__ long unsigned int
#define __PTRDIFF_TYPE__ long int
#define __WCHAR_TYPE__ int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long int
#define __UINTMAX_TYPE__ long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ unsigned int
#define __GXX_ABI_VERSION 1002
#define __SCHAR_MAX__ 127
#define __SHRT_MAX__ 32767
#define __INT_MAX__ 2147483647
#define __LONG_MAX__ 9223372036854775807L
#define __LONG_LONG_MAX__ 9223372036854775807LL
#define __WCHAR_MAX__ 2147483647
#define __CHAR_BIT__ 8
#define __INTMAX_MAX__ 9223372036854775807L
#define __FLT_EVAL_METHOD__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_MAX__ 3.40282347e+38F
#define __FLT_MIN__ 1.17549435e-38F
#define __FLT_EPSILON__ 1.19209290e-7F
#define __FLT_DENORM_MIN__ 1.40129846e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_MAX__ 1.7976931348623157e+308
#define __DBL_MIN__ 2.2250738585072014e-308
#define __DBL_EPSILON__ 2.2204460492503131e-16
#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 113
#define __LDBL_DIG__ 33
#define __LDBL_MIN_EXP__ (-16381)
#define __LDBL_MIN_10_EXP__ (-4931)
#define __LDBL_MAX_EXP__ 16384
#define __LDBL_MAX_10_EXP__ 4932
#define __DECIMAL_DIG__ 36
#define __LDBL_MAX__ 1.18973149535723176508575932662800702e+4932L
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
#define __LDBL_EPSILON__ 1.92592994438723585305597794258492732e-34L
#define __LDBL_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __SFRACT_FBIT__ 7
#define __SFRACT_IBIT__ 0
#define __SFRACT_MIN__ (-0.5HR-0.5HR)
#define __SFRACT_MAX__ 0X7FP-7HR
#define __SFRACT_EPSILON__ 0x1P-7HR
#define __USFRACT_FBIT__ 8
#define __USFRACT_IBIT__ 0
#define __USFRACT_MIN__ 0.0UHR
#define __USFRACT_MAX__ 0XFFP-8UHR
#define __USFRACT_EPSILON__ 0x1P-8UHR
#define __FRACT_FBIT__ 15
#define __FRACT_IBIT__ 0
#define __FRACT_MIN__ (-0.5R-0.5R)
#define __FRACT_MAX__ 0X7FFFP-15R
#define __FRACT_EPSILON__ 0x1P-15R
#define __UFRACT_FBIT__ 16
#define __UFRACT_IBIT__ 0
#define __UFRACT_MIN__ 0.0UR
#define __UFRACT_MAX__ 0XFFFFP-16UR
#define __UFRACT_EPSILON__ 0x1P-16UR
#define __LFRACT_FBIT__ 31
#define __LFRACT_IBIT__ 0
#define __LFRACT_MIN__ (-0.5LR-0.5LR)
#define __LFRACT_MAX__ 0X7FFFFFFFP-31LR
#define __LFRACT_EPSILON__ 0x1P-31LR
#define __ULFRACT_FBIT__ 32
#define __ULFRACT_IBIT__ 0
#define __ULFRACT_MIN__ 0.0ULR
#define __ULFRACT_MAX__ 0XFFFFFFFFP-32ULR
#define __ULFRACT_EPSILON__ 0x1P-32ULR
#define __LLFRACT_FBIT__ 63
#define __LLFRACT_IBIT__ 0
#define __LLFRACT_MIN__ (-0.5LLR-0.5LLR)
#define __LLFRACT_MAX__ 0X7FFFFFFFFFFFFFFFP-63LLR
#define __LLFRACT_EPSILON__ 0x1P-63LLR
#define __ULLFRACT_FBIT__ 64
#define __ULLFRACT_IBIT__ 0
#define __ULLFRACT_MIN__ 0.0ULLR
#define __ULLFRACT_MAX__ 0XFFFFFFFFFFFFFFFFP-64ULLR
#define __ULLFRACT_EPSILON__ 0x1P-64ULLR
#define __SACCUM_FBIT__ 7
#define __SACCUM_IBIT__ 8
#define __SACCUM_MIN__ (-0X1P7HK-0X1P7HK)
#define __SACCUM_MAX__ 0X7FFFP-7HK
#define __SACCUM_EPSILON__ 0x1P-7HK
#define __USACCUM_FBIT__ 8
#define __USACCUM_IBIT__ 8
#define __USACCUM_MIN__ 0.0UHK
#define __USACCUM_MAX__ 0XFFFFP-8UHK
#define __USACCUM_EPSILON__ 0x1P-8UHK
#define __ACCUM_FBIT__ 15
#define __ACCUM_IBIT__ 16
#define __ACCUM_MIN__ (-0X1P15K-0X1P15K)
#define __ACCUM_MAX__ 0X7FFFFFFFP-15K
#define __ACCUM_EPSILON__ 0x1P-15K
#define __UACCUM_FBIT__ 16
#define __UACCUM_IBIT__ 16
#define __UACCUM_MIN__ 0.0UK
#define __UACCUM_MAX__ 0XFFFFFFFFP-16UK
#define __UACCUM_EPSILON__ 0x1P-16UK
#define __LACCUM_FBIT__ 31
#define __LACCUM_IBIT__ 32
#define __LACCUM_MIN__ (-0X1P31LK-0X1P31LK)
#define __LACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LK
#define __LACCUM_EPSILON__ 0x1P-31LK
#define __ULACCUM_FBIT__ 32
#define __ULACCUM_IBIT__ 32
#define __ULACCUM_MIN__ 0.0ULK
#define __ULACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULK
#define __ULACCUM_EPSILON__ 0x1P-32ULK
#define __LLACCUM_FBIT__ 63
#define __LLACCUM_IBIT__ 64
#define __LLACCUM_MIN__ (-0X1P63LLK-0X1P63LLK)
#define __LLACCUM_MAX__ 0X7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFP-63LLK
#define __LLACCUM_EPSILON__ 0x1P-63LLK
#define __ULLACCUM_FBIT__ 64
#define __ULLACCUM_IBIT__ 64
#define __ULLACCUM_MIN__ 0.0ULLK
#define __ULLACCUM_MAX__ 0XFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFP-64ULLK
#define __ULLACCUM_EPSILON__ 0x1P-64ULLK
#define __QQ_FBIT__ 7
#define __QQ_IBIT__ 0
#define __HQ_FBIT__ 15
#define __HQ_IBIT__ 0
#define __SQ_FBIT__ 31
#define __SQ_IBIT__ 0
#define __DQ_FBIT__ 63
#define __DQ_IBIT__ 0
#define __TQ_FBIT__ 127
#define __TQ_IBIT__ 0
#define __UQQ_FBIT__ 8
#define __UQQ_IBIT__ 0
#define __UHQ_FBIT__ 16
#define __UHQ_IBIT__ 0
#define __USQ_FBIT__ 32
#define __USQ_IBIT__ 0
#define __UDQ_FBIT__ 64
#define __UDQ_IBIT__ 0
#define __UTQ_FBIT__ 128
#define __UTQ_IBIT__ 0
#define __HA_FBIT__ 7
#define __HA_IBIT__ 8
#define __SA_FBIT__ 15
#define __SA_IBIT__ 16
#define __DA_FBIT__ 31
#define __DA_IBIT__ 32
#define __TA_FBIT__ 63
#define __TA_IBIT__ 64
#define __UHA_FBIT__ 8
#define __UHA_IBIT__ 8
#define __USA_FBIT__ 16
#define __USA_IBIT__ 16
#define __UDA_FBIT__ 32
#define __UDA_IBIT__ 32
#define __UTA_FBIT__ 64
#define __UTA_IBIT__ 64
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __VERSION__ "4.4.0"
#define __GNUC_GNU_INLINE__ 1
#define _LP64 1
#define __LP64__ 1
#define __OPTIMIZE__ 1
#define __FINITE_MATH_ONLY__ 0
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 8
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 16
#define __SIZEOF_SIZE_T__ 8
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 8
#define __SIZEOF_POINTER__ 8
#define __mips__ 1
#define _mips 1
#define mips 1
#define __mips64 1
#define __R4000 1
#define __R4000__ 1
#define R4000 1
#define _R4000 1
#define __mips_fpr 64
#define _MIPS_ARCH_MIPS64R2 1
#define _MIPS_ARCH "mips64r2"
#define _MIPS_TUNE_MIPS64R2 1
#define _MIPS_TUNE "mips64r2"
#define __mips 64
#define __mips_isa_rev 2
#define _MIPS_ISA _MIPS_ISA_MIPS64
#define _ABI64 3
#define _MIPS_SIM _ABI64
#define _MIPS_SZINT 32
#define _MIPS_SZLONG 64
#define _MIPS_SZPTR 64
#define _MIPS_FPSET 32
#define __mips_hard_float 1
#define __MIPSEL 1
#define __MIPSEL__ 1
#define MIPSEL 1
#define _MIPSEL 1
#define __LANGUAGE_C 1
#define __LANGUAGE_C__ 1
#define LANGUAGE_C 1
#define _LANGUAGE_C 1
#define __GCC_HAVE_BUILTIN_MIPS_CACHE 1
#define __gnu_linux__ 1
#define __linux 1
#define __linux__ 1
#define linux 1
#define __unix 1
#define __unix__ 1
#define unix 1
#define __ELF__ 1
#define __BIGGEST_ALIGNMENT__ 16
# 1 "<command-line>"
#define GUEST 1
#define CPU_COUNT_PER_US 10
# 1 "include/common.h" 1

#define __COMMON_H__ 
# 1 "include/regdef.h" 1
/*	$OpenBSD: regdef.h,v 1.3 1999/01/27 04:46:06 imp Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell. This file is derived from the MIPS RISC
 * Architecture book by Gerry Kane.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)regdef.h	8.1 (Berkeley) 6/10/93
 */

#define _MIPS_REGDEF_H_ 
# 116 "include/regdef.h"
#define FIFO 0x1F0
#define STACK 0x1E8
#define PARAM 0x1E0
#define PARAMI 0x1E0
#define PARAMO 0x1E0
#define SERIAL 0x1D8
#define FIFO1 0x1D0
#define RTC 0x1C8
#define HEX_ADDR 0x1C0
#define RET_ADDR 0x1B8
#define SPI_IOBASE 0x100
#define LS1DFLASH_IOBASE 0x108

#define DMEM 0x0
# 4 "include/common.h" 2
#define SERIAL_REG (0xffffffffff200000+SERIAL)
#define RTC_REG (0xffffffffff200000+RTC)
#define ARGC_REG (0xffffffffff200000+RET_ADDR)
#define HEX_REG (0xffffffffff200000+HEX_ADDR)

#define ___constant_swab16(x) ((unsigned short)( (((unsigned short)(x) & (unsigned short)0x00ffU) << 8) | (((unsigned short)(x) & (unsigned short)0xff00U) >> 8)))



#define ___constant_swab32(x) ((unsigned int)( (((unsigned int)(x) & (unsigned int)0x000000ffUL) << 24) | (((unsigned int)(x) & (unsigned int)0x0000ff00UL) << 8) | (((unsigned int)(x) & (unsigned int)0x00ff0000UL) >> 8) | (((unsigned int)(x) & (unsigned int)0xff000000UL) >> 24)))





#define ___constant_swab64(x) ((unsigned long long)( (((unsigned long long)(x) & (unsigned long long)0x00000000000000ffULL) << 56) | (((unsigned long long)(x) & (unsigned long long)0x000000000000ff00ULL) << 40) | (((unsigned long long)(x) & (unsigned long long)0x0000000000ff0000ULL) << 24) | (((unsigned long long)(x) & (unsigned long long)0x00000000ff000000ULL) << 8) | (((unsigned long long)(x) & (unsigned long long)0x000000ff00000000ULL) >> 8) | (((unsigned long long)(x) & (unsigned long long)0x0000ff0000000000ULL) >> 24) | (((unsigned long long)(x) & (unsigned long long)0x00ff000000000000ULL) >> 40) | (((unsigned long long)(x) & (unsigned long long)0xff00000000000000ULL) >> 56)))
# 30 "include/common.h"
# 1 "include/stdarg.h" 1

#define __STDARG_H__ 
typedef void * va_list;



#define va_start __builtin_va_start

#define va_arg __builtin_va_arg
#define va_end __builtin_va_end
# 31 "include/common.h" 2
# 1 "include/types.h" 1

#define __TYPE__H__ 
typedef unsigned long long u64;
typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef unsigned int uint;
typedef char __s8;
typedef short __s16;
typedef int __s32;
typedef long long __s64;
typedef char s8;
typedef short s16;
typedef int s32;
typedef long long s64;
typedef unsigned char __u8;
typedef unsigned short __u16;
typedef unsigned int __u32;
typedef unsigned long long __u64;
typedef char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef unsigned char u_char;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned char __le8;
typedef unsigned short __le16;
typedef unsigned int __le32;
typedef unsigned long long __le64;
typedef unsigned int __be32;
typedef int bool;
enum {
false = 0,
true = 1,
};
typedef unsigned long dma_addr_t;
typedef int gfp_t;
typedef unsigned long uintptr_t;
typedef unsigned long phys_addr_t;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

#define __iomem 
#define __packed __attribute__((packed))


#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
#define BITS_PER_LONG _MIPS_SZLONG
#define BIT(nr) (1UL << (nr))
#define BIT_ULL(nr) (1ULL << (nr))
#define BIT_MASK(nr) (1UL << ((nr) % BITS_PER_LONG))
#define BIT_WORD(nr) ((nr) / BITS_PER_LONG)
#define BIT_ULL_MASK(nr) (1ULL << ((nr) % BITS_PER_LONG_LONG))
#define BIT_ULL_WORD(nr) ((nr) / BITS_PER_LONG_LONG)
#define BITS_PER_BYTE 8
#define BITS_TO_LONGS(nr) DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
#define DECLARE_BITMAP(name,bits) unsigned long name[BITS_TO_LONGS(bits)]

typedef unsigned long fdt_addr_t;
typedef long ssize_t;
typedef long long off_t;
typedef long long loff_t;
#define SSIZE_MAX LONG_MAX
typedef u_int32_t pcireg_t; /* configuration space register XXX */
typedef unsigned long device_t;
typedef unsigned int mode_t;
typedef unsigned int dev_t;
typedef long intptr_t;
typedef u_int32_t bus_addr_t;
typedef u_int32_t bus_size_t;
typedef u_int32_t bus_space_handle_t;
typedef unsigned long vaddr_t;
typedef char *caddr_t;
typedef unsigned long vm_offset_t;
typedef unsigned int paddr_t;
typedef unsigned int vm_size_t;
typedef unsigned long size_t;
typedef long long quad_t;
typedef unsigned long long u_quad_t; /* quads */
# 32 "include/common.h" 2
#define __P(x) x
#define SSIZE_MAX LONG_MAX

int printf (const char *fmt, ...);
int newprintf (const char *fmt, ...);
int printbase(long v,int w,int base,int sign);
int snprintbase(char *d, int n, long v,int w,int base,int sign);
int sprintbase(char *d, long v,int w,int base,int sign);
int tvsnprintf(char *buf, int n, const char *fmt, void **arg);
int tsnprintf(char *buf, int n, const char *fmt,...);
int tsprintf(char *buf, const char *fmt,...);
#define isdigit(c) (c>='0' && c<='9')

#define NULL ((void *)0)

#define __read_32bit_c0_register(source,sel) ({ int __res; if (sel == 0) __asm__ __volatile__( "mfc0\t%0, " #source "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " #source ", " #sel "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; })
# 63 "include/common.h"
#define __read_64bit_c0_split(source,sel) ({ unsigned long long val; unsigned long flags; local_irq_save(flags); if (sel == 0) __asm__ __volatile__( ".set\tmips64\n\t" "dmfc0\t%M0, " #source "\n\t" "dsll\t%L0, %M0, 32\n\t" "dsrl\t%M0, %M0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" ".set\tmips0" : "=r" (val)); else __asm__ __volatile__( ".set\tmips64\n\t" "dmfc0\t%M0, " #source ", " #sel "\n\t" "dsll\t%L0, %M0, 32\n\t" "dsrl\t%M0, %M0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" ".set\tmips0" : "=r" (val)); local_irq_restore(flags); val; })
# 92 "include/common.h"
#define __read_64bit_c0_register(source,sel) ({ unsigned long long __res; if (sizeof(unsigned long) == 4) __res = __read_64bit_c0_split(source, sel); else if (sel == 0) __asm__ __volatile__( ".set\tmips3\n\t" "dmfc0\t%0, " #source "\n\t" ".set\tmips0" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips64\n\t" "dmfc0\t%0, " #source ", " #sel "\n\t" ".set\tmips0" : "=r" (__res)); __res; })
# 113 "include/common.h"
#define __write_32bit_c0_register(register,sel,value) do { if (sel == 0) __asm__ __volatile__( "mtc0\t%z0, " #register "\n\t" : : "Jr" ((unsigned int)(value))); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " #register ", " #sel "\n\t" ".set\tmips0" : : "Jr" ((unsigned int)(value))); } while (0)
# 128 "include/common.h"
#define __write_64bit_c0_split(source,sel,val) do { unsigned long flags; local_irq_save(flags); if (sel == 0) __asm__ __volatile__( ".set\tmips64\n\t" "dsll\t%L0, %L0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" "dsll\t%M0, %M0, 32\n\t" "or\t%L0, %L0, %M0\n\t" "dmtc0\t%L0, " #source "\n\t" ".set\tmips0" : : "r" (val)); else __asm__ __volatile__( ".set\tmips64\n\t" "dsll\t%L0, %L0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" "dsll\t%M0, %M0, 32\n\t" "or\t%L0, %L0, %M0\n\t" "dmtc0\t%L0, " #source ", " #sel "\n\t" ".set\tmips0" : : "r" (val)); local_irq_restore(flags); } while (0)
# 156 "include/common.h"
#define __write_64bit_c0_register(register,sel,value) do { if (sizeof(unsigned long) == 4) __write_64bit_c0_split(register, sel, value); else if (sel == 0) __asm__ __volatile__( ".set\tmips3\n\t" "dmtc0\t%z0, " #register "\n\t" ".set\tmips0" : : "Jr" (value)); else __asm__ __volatile__( ".set\tmips64\n\t" "dmtc0\t%z0, " #register ", " #sel "\n\t" ".set\tmips0" : : "Jr" (value)); } while (0)
# 175 "include/common.h"
#define __read_ulong_c0_register(reg,sel) ((sizeof(unsigned long) == 4) ? (unsigned long) __read_32bit_c0_register(reg, sel) : (unsigned long) __read_64bit_c0_register(reg, sel))




#define __write_ulong_c0_register(reg,sel,val) do { if (sizeof(unsigned long) == 4) __write_32bit_c0_register(reg, sel, val); else __write_64bit_c0_register(reg, sel, val); } while (0)
# 190 "include/common.h"
#define read_c0_index() __read_32bit_c0_register($0, 0)
#define write_c0_index(val) __write_32bit_c0_register($0, 0, val)

#define read_c0_entrylo0() __read_ulong_c0_register($2, 0)
#define write_c0_entrylo0(val) __write_ulong_c0_register($2, 0, val)

#define read_c0_entrylo1() __read_ulong_c0_register($3, 0)
#define write_c0_entrylo1(val) __write_ulong_c0_register($3, 0, val)

#define read_c0_conf() __read_32bit_c0_register($3, 0)
#define write_c0_conf(val) __write_32bit_c0_register($3, 0, val)

#define read_c0_context() __read_ulong_c0_register($4, 0)
#define write_c0_context(val) __write_ulong_c0_register($4, 0, val)

#define read_c0_pagemask() __read_32bit_c0_register($5, 0)
#define write_c0_pagemask(val) __write_32bit_c0_register($5, 0, val)

#define read_c0_wired() __read_32bit_c0_register($6, 0)
#define write_c0_wired(val) __write_32bit_c0_register($6, 0, val)

#define read_c0_info() __read_32bit_c0_register($7, 0)

#define read_c0_cache() __read_32bit_c0_register($7, 0)
#define write_c0_cache(val) __write_32bit_c0_register($7, 0, val)

#define read_c0_badvaddr() __read_ulong_c0_register($8, 0)
#define write_c0_badvaddr(val) __write_ulong_c0_register($8, 0, val)

#define read_c0_count() __read_32bit_c0_register($9, 0)
#define write_c0_count(val) __write_32bit_c0_register($9, 0, val)

#define read_c0_count2() __read_32bit_c0_register($9, 6)
#define write_c0_count2(val) __write_32bit_c0_register($9, 6, val)

#define read_c0_count3() __read_32bit_c0_register($9, 7)
#define write_c0_count3(val) __write_32bit_c0_register($9, 7, val)

#define read_c0_entryhi() __read_ulong_c0_register($10, 0)
#define write_c0_entryhi(val) __write_ulong_c0_register($10, 0, val)

#define read_c0_compare() __read_32bit_c0_register($11, 0)
#define write_c0_compare(val) __write_32bit_c0_register($11, 0, val)

#define read_c0_compare2() __read_32bit_c0_register($11, 6)
#define write_c0_compare2(val) __write_32bit_c0_register($11, 6, val)

#define read_c0_compare3() __read_32bit_c0_register($11, 7)
#define write_c0_compare3(val) __write_32bit_c0_register($11, 7, val)

#define read_c0_status() __read_32bit_c0_register($12, 0)

#define write_c0_status(val) __write_32bit_c0_register($12, 0, val)


#define read_c0_cause() __read_32bit_c0_register($13, 0)
#define write_c0_cause(val) __write_32bit_c0_register($13, 0, val)

#define read_c0_epc() __read_ulong_c0_register($14, 0)
#define write_c0_epc(val) __write_ulong_c0_register($14, 0, val)

#define read_c0_prid() __read_32bit_c0_register($15, 0)

#define read_c0_config() __read_32bit_c0_register($16, 0)
#define read_c0_config1() __read_32bit_c0_register($16, 1)
#define read_c0_config2() __read_32bit_c0_register($16, 2)
#define read_c0_config3() __read_32bit_c0_register($16, 3)
#define read_c0_config4() __read_32bit_c0_register($16, 4)
#define read_c0_config5() __read_32bit_c0_register($16, 5)
#define read_c0_config6() __read_32bit_c0_register($16, 6)
#define read_c0_config7() __read_32bit_c0_register($16, 7)
#define write_c0_config(val) __write_32bit_c0_register($16, 0, val)
#define write_c0_config1(val) __write_32bit_c0_register($16, 1, val)
#define write_c0_config2(val) __write_32bit_c0_register($16, 2, val)
#define write_c0_config3(val) __write_32bit_c0_register($16, 3, val)
#define write_c0_config4(val) __write_32bit_c0_register($16, 4, val)
#define write_c0_config5(val) __write_32bit_c0_register($16, 5, val)
#define write_c0_config6(val) __write_32bit_c0_register($16, 6, val)
#define write_c0_config7(val) __write_32bit_c0_register($16, 7, val)

/*
 * The WatchLo register.  There may be upto 8 of them.
 */
#define read_c0_watchlo0() __read_ulong_c0_register($18, 0)
#define read_c0_watchlo1() __read_ulong_c0_register($18, 1)
#define read_c0_watchlo2() __read_ulong_c0_register($18, 2)
#define read_c0_watchlo3() __read_ulong_c0_register($18, 3)
#define read_c0_watchlo4() __read_ulong_c0_register($18, 4)
#define read_c0_watchlo5() __read_ulong_c0_register($18, 5)
#define read_c0_watchlo6() __read_ulong_c0_register($18, 6)
#define read_c0_watchlo7() __read_ulong_c0_register($18, 7)
#define write_c0_watchlo0(val) __write_ulong_c0_register($18, 0, val)
#define write_c0_watchlo1(val) __write_ulong_c0_register($18, 1, val)
#define write_c0_watchlo2(val) __write_ulong_c0_register($18, 2, val)
#define write_c0_watchlo3(val) __write_ulong_c0_register($18, 3, val)
#define write_c0_watchlo4(val) __write_ulong_c0_register($18, 4, val)
#define write_c0_watchlo5(val) __write_ulong_c0_register($18, 5, val)
#define write_c0_watchlo6(val) __write_ulong_c0_register($18, 6, val)
#define write_c0_watchlo7(val) __write_ulong_c0_register($18, 7, val)

/*
 * The WatchHi register.  There may be upto 8 of them.
 */
#define read_c0_watchhi0() __read_32bit_c0_register($19, 0)
#define read_c0_watchhi1() __read_32bit_c0_register($19, 1)
#define read_c0_watchhi2() __read_32bit_c0_register($19, 2)
#define read_c0_watchhi3() __read_32bit_c0_register($19, 3)
#define read_c0_watchhi4() __read_32bit_c0_register($19, 4)
#define read_c0_watchhi5() __read_32bit_c0_register($19, 5)
#define read_c0_watchhi6() __read_32bit_c0_register($19, 6)
#define read_c0_watchhi7() __read_32bit_c0_register($19, 7)

#define write_c0_watchhi0(val) __write_32bit_c0_register($19, 0, val)
#define write_c0_watchhi1(val) __write_32bit_c0_register($19, 1, val)
#define write_c0_watchhi2(val) __write_32bit_c0_register($19, 2, val)
#define write_c0_watchhi3(val) __write_32bit_c0_register($19, 3, val)
#define write_c0_watchhi4(val) __write_32bit_c0_register($19, 4, val)
#define write_c0_watchhi5(val) __write_32bit_c0_register($19, 5, val)
#define write_c0_watchhi6(val) __write_32bit_c0_register($19, 6, val)
#define write_c0_watchhi7(val) __write_32bit_c0_register($19, 7, val)


static inline void tlb_write_indexed(void)
{
 __asm__ __volatile__(
  ".set noreorder\n\t"
  "tlbwi\n\t"
  ".set reorder");
}
void * malloc(size_t nbytes);
void * malloc_align(size_t nbytes, int align);
void * zalloc_align(size_t nbytes, int align);
void free(void *ap);
void * memset(void * s,int c, size_t count);
#define __always_inline inline __attribute__((always_inline))
#define noinline __attribute__((noinline))
#define __deprecated __attribute__((deprecated))
#define __packed __attribute__((packed))
#define __weak __attribute__((weak))
#define __alias(symbol) __attribute__((alias(#symbol)))
#define __attribute_const__ __attribute__((__const__))
#define __maybe_unused __attribute__((unused))
#define __always_unused __attribute__((unused))
#define __aligned(x) __attribute__((aligned(x)))
#define ROUND(a,b) (((a) + (b) - 1) & ~((b) - 1))
# 1 "<command-line>" 2
# 1 "/loongson/ejtag-debug/bin/Eep_8000.c"
/*******************************************************************************
 * Copyright 2013-2018 Avago Technologies
 * Copyright (c) 2009 to 2012 PLX Technology Inc.  All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
 * General Public License (GPL) Version 2, available from the file
 * COPYING in the main directorY of this source tree, or the
 * BSD license below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ******************************************************************************/

/******************************************************************************
 *
 * File Name:
 *
 *      Eep_8000.c
 *
 * Description:
 *
 *      This file contains 8000-series EEPROM support functions
 *
 * Revision History:
 *
 *      01-01-18 : PLX SDK v8.00
 *
 ******************************************************************************/


# 1 "/loongson/ejtag-debug/bin/Eep_8000.h" 1

#define __EEP_8000_H 

/*******************************************************************************
 * Copyright 2013-2015 Avago Technologies
 * Copyright (c) 2009 to 2012 PLX Technology Inc.  All rights reserved.
 *
 * This software is available to you under a choice of one of two
 * licenses.  You may choose to be licensed under the terms of the GNU
 * General Public License (GPL) Version 2, available from the file
 * COPYING in the main directorY of this source tree, or the
 * BSD license below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ******************************************************************************/

/******************************************************************************
 *
 * File Name:
 *
 *      Eep_8000.h
 *
 * Description:
 *
 *      The include file for 8000-series EEPROM support functions
 *
 * Revision History:
 *
 *      08-01-11 : PLX SDK v6.50
 *
 ******************************************************************************/


//#include "DrvDefs.h"

typedef int PLX_STATUS;
#define PLX_STATUS_START 0

typedef enum _PLX_STATUS_CODE
{
    PLX_STATUS_OK = 0,
    PLX_STATUS_FAILED,
    PLX_STATUS_NULL_PARAM,
    PLX_STATUS_UNSUPPORTED,
    PLX_STATUS_NO_DRIVER,
    PLX_STATUS_INVALID_OBJECT,
    PLX_STATUS_VER_MISMATCH,
    PLX_STATUS_INVALID_OFFSET,
    PLX_STATUS_INVALID_DATA,
    PLX_STATUS_INVALID_SIZE,
    PLX_STATUS_INVALID_ADDR,
    PLX_STATUS_INVALID_ACCESS,
    PLX_STATUS_INSUFFICIENT_RES,
    PLX_STATUS_TIMEOUT,
    PLX_STATUS_CANCELED,
    PLX_STATUS_COMPLETE,
    PLX_STATUS_PAUSED,
    PLX_STATUS_IN_PROGRESS,
    PLX_STATUS_PAGE_GET_ERROR,
    PLX_STATUS_PAGE_LOCK_ERROR,
    PLX_STATUS_LOW_POWER,
    PLX_STATUS_IN_USE,
    PLX_STATUS_DISABLED,
    PLX_STATUS_PENDING,
    PLX_STATUS_NOT_FOUND,
    PLX_STATUS_INVALID_STATE,
    PLX_STATUS_BUFF_TOO_SMALL,
    PLX_STATUS_RSVD_LAST_ERROR // Do not add API errors below this line
} PLX_STATUS_CODE;


// EEPROM status
typedef enum _PLX_EEPROM_STATUS
{
    PLX_EEPROM_STATUS_NONE = 0, // Not present
    PLX_EEPROM_STATUS_VALID = 1, // Present with valid data
    PLX_EEPROM_STATUS_INVALID_DATA = 2, // Present w/invalid data or CRC error
    PLX_EEPROM_STATUS_BLANK = PLX_EEPROM_STATUS_INVALID_DATA,
    PLX_EEPROM_STATUS_CRC_ERROR = PLX_EEPROM_STATUS_INVALID_DATA
} PLX_EEPROM_STATUS;


// EEPROM CRC status
typedef enum _PLX_CRC_STATUS
{
    PLX_CRC_INVALID = 0,
    PLX_CRC_VALID = 1,
    PLX_CRC_UNSUPPORTED = 2,
    PLX_CRC_UNKNOWN = 3
} PLX_CRC_STATUS;


// PLX chip families
typedef enum _PLX_CHIP_FAMILY
{
    PLX_FAMILY_NONE = 0,
    PLX_FAMILY_UNKNOWN,
    PLX_FAMILY_BRIDGE_P2L, // 9000 series & 8311
    PLX_FAMILY_BRIDGE_PCI_P2P, // 6000 series
    PLX_FAMILY_BRIDGE_PCIE_P2P, // 8111,8112,8114
    PLX_FAMILY_ALTAIR, // 8525,8533,8547,8548
    PLX_FAMILY_ALTAIR_XL, // 8505,8509
    PLX_FAMILY_VEGA, // 8516,8524,8532
    PLX_FAMILY_VEGA_LITE, // 8508,8512,8517,8518
    PLX_FAMILY_DENEB, // 8612,8616,8624,8632,8647,8648
    PLX_FAMILY_SIRIUS, // 8604,8606,8608,8609,8613,8614,8615
                                        //   8617,8618,8619
    PLX_FAMILY_CYGNUS, // 8625,8636,8649,8664,8680,8696
    PLX_FAMILY_SCOUT, // 8700
    PLX_FAMILY_DRACO_1, // 8712,8716,8724,8732,8747,8748,8749
    PLX_FAMILY_DRACO_2, // 8713,8717,8725,8733 + [Draco 1 rev BA]
    PLX_FAMILY_MIRA, // 2380,3380,3382,8603,8605
    PLX_FAMILY_CAPELLA_1, // 8714,8718,8734,8750,8764,8780,8796
    PLX_FAMILY_CAPELLA_2, // 9712,9716,9733,9749,9750,9765,9781,9797
    PLX_FAMILY_ATLAS, // C010,C011,C012
    PLX_FAMILY_LAST_ENTRY // -- Must be final entry --
} PLX_CHIP_FAMILY;

// Mode PLX API uses to access device
typedef enum _PLX_API_MODE
{
    PLX_API_MODE_PCI, // Device accessed via PLX driver over PCI/PCIe
    PLX_API_MODE_I2C_AARDVARK, // Device accessed via Aardvark I2C USB
    PLX_API_MODE_MDIO_SPLICE, // Device accessed via Splice MDIO USB
    PLX_API_MODE_SDB, // Device accessed via Serial Debug Port
    PLX_API_MODE_TCP // Device accessed via TCP/IP
} PLX_API_MODE;


// Port types
typedef enum _PLX_PORT_TYPE
{
    PLX_PORT_UNKNOWN = 0xFF,
    PLX_PORT_ENDPOINT = 0,
    PLX_PORT_LEGACY_ENDPOINT = 1,
    PLX_PORT_ROOT_PORT = 4,
    PLX_PORT_UPSTREAM = 5,
    PLX_PORT_DOWNSTREAM = 6,
    PLX_PORT_PCIE_TO_PCI_BRIDGE = 7,
    PLX_PORT_PCI_TO_PCIE_BRIDGE = 8,
    PLX_PORT_ROOT_ENDPOINT = 9,
    PLX_PORT_ROOT_EVENT_COLL = 10
} PLX_PORT_TYPE;

// PLX port flags for mask
typedef enum _PLX_FLAG_PORT
{
    PLX_FLAG_PORT_NT_LINK_1 = 63, // Bit for NT Link port 0
    PLX_FLAG_PORT_NT_LINK_0 = 62, // Bit for NT Link port 1
    PLX_FLAG_PORT_NT_VIRTUAL_1 = 61, // Bit for NT Virtual port 0
    PLX_FLAG_PORT_NT_VIRTUAL_0 = 60, // Bit for NT Virtual port 1
    PLX_FLAG_PORT_NT_DS_P2P = 59, // Bit for NT DS P2P port (Virtual)
    PLX_FLAG_PORT_DMA_RAM = 58, // Bit for DMA RAM
    PLX_FLAG_PORT_DMA_3 = 57, // Bit for DMA channel 3
    PLX_FLAG_PORT_DMA_2 = 56, // Bit for DMA channel 2
    PLX_FLAG_PORT_DMA_1 = 55, // Bit for DMA channel 1
    PLX_FLAG_PORT_DMA_0 = 54, // Bit for DMA ch 0 or Func 1 (all 4 ch)
    PLX_FLAG_PORT_PCIE_TO_USB = 53, // Bit for PCIe-to-USB P2P or Root Port
    PLX_FLAG_PORT_USB = 52, // Bit for USB Host/Bridge
    PLX_FLAG_PORT_ALUT_3 = 51, // Bit for ALUT RAM arrays 0
    PLX_FLAG_PORT_ALUT_2 = 50, // Bit for ALUT RAM arrays 1
    PLX_FLAG_PORT_ALUT_1 = 49, // Bit for ALUT RAM arrays 2
    PLX_FLAG_PORT_ALUT_0 = 48, // Bit for ALUT RAM arrays 3
    PLX_FLAG_PORT_STN_REGS_S5 = 47, // Bit for VS or Fabric mode station 0 specific regs
    PLX_FLAG_PORT_STN_REGS_S4 = 46, // Bit for VS or Fabric mode station 1 specific regs
    PLX_FLAG_PORT_STN_REGS_S3 = 45, // Bit for VS or Fabric mode station 2 specific regs
    PLX_FLAG_PORT_STN_REGS_S2 = 44, // Bit for VS or Fabric mode station 3 specific regs
    PLX_FLAG_PORT_STN_REGS_S1 = 43, // Bit for VS or Fabric mode station 4 specific regs
    PLX_FLAG_PORT_STN_REGS_S0 = 42, // Bit for VS or Fabric mode station 5 specific regs
    PLX_FLAG_PORT_MAX = 41, // Bit for highest possible standard port

 // Flags below are special ports for GEP (24) & its parent P2P (25)
    PLX_FLAG_PORT_GEP = 24,
    PLX_FLAG_PORT_GEP_P2P = 25
} PLX_FLAG_PORT;

typedef unsigned char U8;
typedef unsigned short U16;
typedef unsigned int U32;
typedef int BOOLEAN;
typedef void VOID;


// PCI Device Key Identifier
typedef struct _PLX_DEVICE_KEY
{
    U32 IsValidTag; // Magic number to determine validity
    U8 domain; // Physical device location
    U8 bus;
    U8 slot;
    U8 function;
    U16 VendorId; // Device Identifier
    U16 DeviceId;
    U16 SubVendorId;
    U16 SubDeviceId;
    U8 Revision;
    U16 PlxChip; // PLX chip type
    U8 PlxRevision; // PLX chip revision
    U8 PlxFamily; // PLX chip family
    U8 ApiIndex; // Used internally by the API
    U16 DeviceNumber; // Used internally by device drivers
    U8 ApiMode; // Mode API uses to access device
    U8 PlxPort; // PLX port number of device
    union
    {
        U8 PlxPortType; // PLX-specific port type (NT/DMA/Host/etc)
        U8 NTPortType; // (Deprecated) If NT, stores NT port type
    };
    U8 NTPortNum; // If NT port exists, store NT port number
    U8 DeviceMode; // Device mode used internally by API
    U32 ApiInternal[2]; // Reserved for internal PLX API use
} PLX_DEVICE_KEY;

typedef struct plx800 {
 unsigned long long base;

 PLX_DEVICE_KEY Key; // Device location & identification
} DEVICE_EXTENSION;
DEVICE_EXTENSION Plx = {
.base = 0x9000000041100000ULL,
.Key = {
.PlxChip = 0x8619,
.PlxFamily = PLX_FAMILY_SIRIUS,
.ApiMode = PLX_API_MODE_PCI,
},
};

#define FALSE 0
#define TRUE 1

#define PLX_8000_REG_READ(pdx,offset) (*(volatile unsigned int *)(pdx->base+offset))
#define PLX_8000_REG_WRITE(pdx,offset,val) (*(volatile unsigned int *)(pdx->base+offset) = (val))
#define DebugPrintf(x) printf x
#define Plx_sleep udelay
# 265 "/loongson/ejtag-debug/bin/Eep_8000.h"
/**********************************************
*               Definitions
**********************************************/
#define CONST_CRC_XOR_VALUE 0xDB710641

// PLX 8000-series EEPROM definitions
#define PLX8000_EE_CMD_READ 3
#define PLX8000_EE_CMD_READ_STATUS 5
#define PLX8000_EE_CMD_WRITE_ENABLE 6
#define PLX8000_EE_CMD_WRITE_DISABLE 4
#define PLX8000_EE_CMD_WRITE 2
#define PLX8000_EE_CMD_WRITE_STATUS 1




/**********************************************
*               Functions
**********************************************/
PLX_STATUS
Plx8000_EepromPresent(
    DEVICE_EXTENSION *pdx,
    U8 *pStatus
    );

PLX_STATUS
Plx8000_EepromGetAddressWidth(
    DEVICE_EXTENSION *pdx,
    U8 *pWidth
    );

PLX_STATUS
Plx8000_EepromSetAddressWidth(
    DEVICE_EXTENSION *pdx,
    U8 width
    );

PLX_STATUS
Plx8000_EepromCrcGet(
    DEVICE_EXTENSION *pdx,
    U32 *pCrc,
    U8 *pCrcStatus
    );

PLX_STATUS
Plx8000_EepromCrcUpdate(
    DEVICE_EXTENSION *pdx,
    U32 *pCrc,
    BOOLEAN bUpdateEeprom
    );

PLX_STATUS
Plx8000_EepromReadByOffset(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U32 *pValue
    );

PLX_STATUS
Plx8000_EepromWriteByOffset(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U32 value
    );

PLX_STATUS
Plx8000_EepromReadByOffset_16(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U16 *pValue
    );

PLX_STATUS
Plx8000_EepromWriteByOffset_16(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U16 value
    );

BOOLEAN
Plx8000_EepromWaitIdle(
    DEVICE_EXTENSION *pdx
    );

BOOLEAN
Plx8000_EepromSendCommand(
    DEVICE_EXTENSION *pdx,
    U32 command
    );

VOID
Plx8000_EepromComputeNextCrc(
    U32 *pCrc,
    U32 NextEepromValue
    );

U16
Plx8000_EepromGetCtrlOffset(
    DEVICE_EXTENSION *pdx
    );
# 52 "/loongson/ejtag-debug/bin/Eep_8000.c" 2
//#include "SuppFunc.h"




/******************************************************************************
 *
 * Function   :  Plx8000_EepromPresent
 *
 * Description:  Returns the state of the EEPROM as reported by the PLX device
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromPresent(
    DEVICE_EXTENSION *pdx,
    U8 *pStatus
    )
{
    U16 OffsetCtrl;
    U32 RegValue;


    // Get EEPROM control register offset
    OffsetCtrl = Plx8000_EepromGetCtrlOffset( pdx );

    // Verify access is supported
    if (OffsetCtrl == 0x0)
    {
        *pStatus = PLX_EEPROM_STATUS_NONE;
        return PLX_STATUS_UNSUPPORTED;
    }

    // Get EEPROM Control/Status
    RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

    // Check if an EEPROM is present (bit 16)
    if (RegValue & (1 << 16))
    {
        // Check if there is a CRC error or EEPROM is blank
        if (RegValue & (1 << 17))
        {
            *pStatus = PLX_EEPROM_STATUS_CRC_ERROR;
        }
        else
        {
            *pStatus = PLX_EEPROM_STATUS_VALID;
        }
    }
    else
    {
        *pStatus = PLX_EEPROM_STATUS_NONE;
    }

    return PLX_STATUS_OK;
}




/*******************************************************************************
 *
 * Function   :  Plx8000_EepromGetAddressWidth
 *
 * Description:  Returns the current EEPROM address width
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromGetAddressWidth(
    DEVICE_EXTENSION *pdx,
    U8 *pWidth
    )
{
    U16 OffsetCtrl;
    U32 RegValue;


    // Default to unknown width
    *pWidth = 0;

    // Get EEPROM control register offset
    OffsetCtrl = Plx8000_EepromGetCtrlOffset( pdx );

    // Verify access is supported
    if (OffsetCtrl == 0x0)
    {
        return PLX_STATUS_UNSUPPORTED;
    }

    // Get EEPROM Control/Status
    RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

    *pWidth = (U8)(RegValue >> 22) & 0x3;

    if (*pWidth == 0xFF)
    {
        *pWidth = 0;
    }

    return PLX_STATUS_OK;
}




/*******************************************************************************
 *
 * Function   :  Plx8000_EepromSetAddressWidth
 *
 * Description:  Sets a new EEPROM address width
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromSetAddressWidth(
    DEVICE_EXTENSION *pdx,
    U8 width
    )
{
    U16 OffsetCtrl;
    U32 RegValue;


    // Get EEPROM control register offset
    OffsetCtrl = Plx8000_EepromGetCtrlOffset( pdx );

    // Verify access is supported
    if (OffsetCtrl == 0x0)
    {
        return PLX_STATUS_UNSUPPORTED;
    }

    // Get EEPROM Control/Status
    RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

    // Clear command field [15:13] to avoid EEPROM cycle
    RegValue &= ~(7 << 13);

    // Set address width override enable
    RegValue |= (1 << 21);

    // Enable override
    (*(volatile unsigned int *)(pdx->base+OffsetCtrl) = (RegValue));

    // Verify width is overridable
    RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

    if ((RegValue & (1 << 21)) == 0)
    {
        printf ("ERROR - EEPROM width override not supported\n");
        return PLX_STATUS_UNSUPPORTED;
    }

    // Clear command field [15:13] to avoid EEPROM cycle
    RegValue &= ~(7 << 13);

    // Clear wdith field [23:22]
    RegValue &= ~(3 << 22);

    // Set address width [23:22]
    RegValue |= ((width & 0x3) << 22);

    // Set new address width
    (*(volatile unsigned int *)(pdx->base+OffsetCtrl) = (RegValue));

    return PLX_STATUS_OK;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromCrcGet
 *
 * Description:  Returns the current value of the CRC and its status
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromCrcGet(
    DEVICE_EXTENSION *pdx,
    U32 *pCrc,
    U8 *pCrcStatus
    )
{
    U16 OffsetCrc;
    U16 Value_16;
    U32 Value_32;


    // Set default return values
    *pCrc = 0;
    *pCrcStatus = PLX_CRC_UNSUPPORTED;

    // Determine the CRC EEPROM offset
    switch (pdx->Key.PlxFamily)
    {
        case PLX_FAMILY_BRIDGE_PCIE_P2P:
            // 8111/8112 don't support CRC
            if (pdx->Key.PlxChip != 0x8114)
            {
                return PLX_STATUS_UNSUPPORTED;
            }

            if (pdx->Key.PlxRevision >= 0xBA)
            {
                OffsetCrc = 0x3EC;
            }
            else
            {
                OffsetCrc = 0x378;
            }
            break;

        case PLX_FAMILY_VEGA_LITE:
            OffsetCrc = 0x78F * sizeof(U32);
            break;

        case PLX_FAMILY_VEGA:
            OffsetCrc = 0xBE4 * sizeof(U32);
            break;

        case PLX_FAMILY_DRACO_2:
        case PLX_FAMILY_CAPELLA_1:
        case PLX_FAMILY_CAPELLA_2:
            // Determine EEPROM size to get CRC location
            Plx8000_EepromReadByOffset( pdx, 0, &Value_32 );

            // Verify valid size
            if ((Value_32 >> 16) == 0xFFFF)
            {
                printf ("ERROR - EEPROM byte count invalid\n");
                *pCrcStatus = PLX_CRC_INVALID;
                return PLX_STATUS_INVALID_DATA;
            }

            // CRC location after reg addr/data values
            OffsetCrc = (U16)(sizeof(U32) + (Value_32 >> 16));
            break;

        default:
            printf ("ERROR - Device (%04X) doesn't support CRC\n", pdx->Key.PlxChip);
            return PLX_STATUS_UNSUPPORTED;
    }

    // Read CRC from EEPROM
    if (((pdx->Key.PlxChip & 0xFF00) == 0x8100) ||
        ((pdx->Key.PlxChip & 0xFF00) == 0x8500))
    {
        Plx8000_EepromReadByOffset( pdx, OffsetCrc, pCrc );
    }
    else
    {
        Plx8000_EepromReadByOffset_16( pdx, OffsetCrc, &Value_16 );
        *pCrc = Value_16;
        Plx8000_EepromReadByOffset_16( pdx, OffsetCrc + sizeof(U16), &Value_16 );
        *pCrc |= (U32)(Value_16) << 16;
    }

    // Get EEPROM and CRC status
    Value_32 = (*(volatile unsigned int *)(pdx->base+0x260));

    // Get EEPROM status bits [17:16]
    Value_32 = (Value_32 >> 16) & 0x3;

    if (Value_32 == 1)
    {
        *pCrcStatus = PLX_CRC_VALID;
    }
    else
    {
        *pCrcStatus = PLX_CRC_INVALID;
    }

    printf ( "CRC = %08Xh [%s] (offset=%02Xh)\n", (int)*pCrc, (*pCrcStatus == PLX_CRC_VALID) ? "Valid" : "Invalid or Undetermined", OffsetCrc );






    return PLX_STATUS_OK;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromCrcUpdate
 *
 * Description:  Calculates and updates the CRC value in the EEPROM
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromCrcUpdate(
    DEVICE_EXTENSION *pdx,
    U32 *pCrc,
    BOOLEAN bUpdateEeprom
    )
{
    U16 offset;
    U16 OffsetCrc;
    U16 OffsetCalcStart;
    U16 Value_16;
    U32 Crc;
    U32 Value_32;


    // Set starting offset for CRC calculations
    OffsetCalcStart = 0;

    // Determine the CRC EEPROM offset
    switch (pdx->Key.PlxFamily)
    {
        case PLX_FAMILY_BRIDGE_PCIE_P2P:
            // 8111/8112 don't support CRC
            if (pdx->Key.PlxChip != 0x8114)
            {
                return PLX_STATUS_UNSUPPORTED;
            }

            if (pdx->Key.PlxRevision >= 0xBA)
            {
                OffsetCrc = 0x3EC;
            }
            else
            {
                OffsetCrc = 0x378;
            }
            break;

        case PLX_FAMILY_VEGA_LITE:
            OffsetCrc = 0x78F * sizeof(U32);
            break;

        case PLX_FAMILY_VEGA:
            OffsetCrc = 0xBE4 * sizeof(U32);
            break;

        case PLX_FAMILY_DRACO_2:
        case PLX_FAMILY_CAPELLA_1:
        case PLX_FAMILY_CAPELLA_2:
            // Determine EEPROM size to get CRC location
            Plx8000_EepromReadByOffset( pdx, 0, &Value_32 );

            // Verify valid size
            if ((Value_32 >> 16) == 0xFFFF)
            {
                printf ("ERROR - EEPROM byte count invalid\n");
                return PLX_STATUS_INVALID_DATA;
            }

            // CRC location after EEPROM (header + reg addr/data values)
            OffsetCrc = (U16)(sizeof(U32) + (Value_32 >> 16));

            // CRC calculation starts at byte 2
            OffsetCalcStart = 2;
            break;

        default:
            printf ("ERROR - Device (%04X) doesn't support CRC\n", pdx->Key.PlxChip);
            return PLX_STATUS_UNSUPPORTED;
    }

    // Initialize CRC
    Crc = (U32)-1;

    // Calculate CRC by reading all values in EEPROM
    for (offset = OffsetCalcStart; offset < OffsetCrc; offset += sizeof(U32))
    {
        // Read next EEPROM value
        if (offset & 0x3)
        {
            // EEPROM offsets are not DWord aligned, must build 16-bits at a time
            Plx8000_EepromReadByOffset_16( pdx, offset, &Value_16 );
            Value_32 = Value_16;

            // If final data not aligned on DWord, pad with 0's
            if ((offset + sizeof(U16)) < OffsetCrc)
            {
                Plx8000_EepromReadByOffset_16( pdx, offset + sizeof(U16), &Value_16 );
            }
            else
            {
                Value_16 = 0;
            }
            Value_32 |= ((U32)Value_16) << 16;
        }
        else
        {
            Plx8000_EepromReadByOffset( pdx, offset, &Value_32 );
        }

        // Update the CRC
        Plx8000_EepromComputeNextCrc( &Crc, Value_32 );
    }

    printf ("Calculated CRC = %08Xh (offset=%02Xh)\n", (int)Crc, OffsetCrc);

    // Update CRC in EEPROM if requested
    if (bUpdateEeprom)
    {
        printf ("Write new CRC to EEPROM\n");
        if (OffsetCrc & 0x3)
        {
            Plx8000_EepromWriteByOffset_16( pdx, OffsetCrc, (U16)Crc );
            Plx8000_EepromWriteByOffset_16( pdx, OffsetCrc + sizeof(U16), (U16)(Crc >> 16) );
        }
        else
        {
            Plx8000_EepromWriteByOffset( pdx, OffsetCrc, Crc );
        }
    }
    else
    {
        printf ("Skipping CRC update in EEPROM\n");
    }

    // Return the new CRC
    *pCrc = Crc;

    return PLX_STATUS_OK;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromReadByOffset
 *
 * Description:  Read a 32-bit value from the EEPROM at a specified offset
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromReadByOffset(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U32 *pValue
    )
{
    U16 OffsetCtrl;
    U32 EepWidth;
    U32 RegValue;
    U32 RegUpper;


    // Clear return data
    *pValue = 0;

    // Get EEPROM control register offset
    OffsetCtrl = Plx8000_EepromGetCtrlOffset( pdx );

    // Verify access is supported
    if (OffsetCtrl == 0x0)
    {
        return PLX_STATUS_UNSUPPORTED;
    }

    // Wait until EEPROM is ready
    if (Plx8000_EepromWaitIdle( pdx ) == 0)
    {
        return PLX_STATUS_TIMEOUT;
    }

    // Get EEPROM control register
    RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

    // Some devices don't report byte addressing
    if ((pdx->Key.PlxChip == 0x8114) ||
        (pdx->Key.PlxFamily == PLX_FAMILY_VEGA) ||
        (pdx->Key.PlxFamily == PLX_FAMILY_VEGA_LITE))
    {
        EepWidth = 2;
    }
    else
    {
        // Determine byte addressing ([23:22])
        EepWidth = (RegValue >> 22) & 0x3;
        if (EepWidth == 0)
        {
           EepWidth = 1;
        }
    }

    // Verify offset doesn't exceed byte addressing
    if (offset >= ((U32)1 << (EepWidth * 8)))
    {
        printf ( "ERROR - Offset (%02Xh) exceeds %dB addressing\n", (int)offset, (int)EepWidth );



        return PLX_STATUS_INVALID_OFFSET;
    }

    // For 3-byte addressing, set upper byte
    if (EepWidth == 3)
    {
        RegUpper = (*(volatile unsigned int *)(pdx->base+OffsetCtrl + 0xC));

        // Set 3rd address byte (26Ch[7:0])
        RegUpper &= ~(0xFF << 0);
        RegUpper |= (offset >> 16) & 0xFF;

        (*(volatile unsigned int *)(pdx->base+OffsetCtrl + 0xC) = (RegUpper));
    }

    // Convert offset to an index
    offset = (offset / sizeof(U32));

    // Clear command field [15:13]
    RegValue &= ~(7 << 13);

    // Clear offset field [20,12:0]
    RegValue &= ~((1 << 20) | (0x1FFF << 0));

    // Prepare EEPROM read command
    RegValue |=
        ((offset & 0x1FFF) << 0) | // Bits [12:0] of offset
        (((offset >> 13) & 1) << 20) | // Bit 13 of offset
        (3 << 13); // EEPROM command

    // Send EEPROM command
    Plx8000_EepromSendCommand( pdx, RegValue );

    // Return EEPROM data (x264h)
    *pValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl + 0x4));

    return PLX_STATUS_OK;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromWriteByOffset
 *
 * Description:  Write a 32-bit value to the EEPROM at a specified offset
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromWriteByOffset(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U32 value
    )
{
    U16 OffsetCtrl;
    U32 EepWidth;
    U32 RegValue;
    U32 RegUpper;


    // Get EEPROM control register offset
    OffsetCtrl = Plx8000_EepromGetCtrlOffset( pdx );

    // Verify access is supported
    if (OffsetCtrl == 0x0)
    {
        return PLX_STATUS_UNSUPPORTED;
    }

    // Wait until EEPROM is ready
    if (Plx8000_EepromWaitIdle( pdx ) == 0)
    {
        return PLX_STATUS_TIMEOUT;
    }

    // Get EEPROM control register
    RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

    // Some devices don't report byte addressing
    if ((pdx->Key.PlxChip == 0x8114) ||
        (pdx->Key.PlxFamily == PLX_FAMILY_VEGA) ||
        (pdx->Key.PlxFamily == PLX_FAMILY_VEGA_LITE))
    {
        EepWidth = 2;
    }
    else
    {
        // Determine byte addressing ([23:22])
        EepWidth = (RegValue >> 22) & 0x3;
        if (EepWidth == 0)
        {
           EepWidth = 1;
        }
    }

    // Verify offset doesn't exceed byte addressing
    if (offset >= ((U32)1 << (EepWidth * 8)))
    {
        printf ( "ERROR - Offset (%02Xh) exceeds %dB addressing\n", (int)offset, (int)EepWidth );



        return PLX_STATUS_INVALID_OFFSET;
    }

    // For 3-byte addressing, set upper byte
    if (EepWidth == 3)
    {
        RegUpper = (*(volatile unsigned int *)(pdx->base+OffsetCtrl + 0xC));

        // Set 3rd address byte (26Ch[7:0])
        RegUpper &= ~(0xFF << 0);
        RegUpper |= (offset >> 16) & 0xFF;

        (*(volatile unsigned int *)(pdx->base+OffsetCtrl + 0xC) = (RegUpper));
    }

    // Convert offset to an index
    offset = (offset / sizeof(U32));

    // Clear command field [15:13]
    RegValue &= ~(7 << 13);

    // Clear offset field [20,12:0]
    RegValue &= ~((1 << 20) | (0x1FFF << 0));

    // Send EEPROM write enable command
    Plx8000_EepromSendCommand(
        pdx,
        RegValue | (6 << 13)
        );

    // Prepare EEPROM data (264h)
    (*(volatile unsigned int *)(pdx->base+OffsetCtrl + 0x4) = (value));

    // Prepare EEPROM write command
    RegValue |=
        ((offset & 0x1FFF) << 0) | // Bits [12:0] of offset
        (((offset >> 13) & 1) << 20) | // Bit 13 of offset
        (2 << 13); // EEPROM command

    // Send EEPROM write command
    Plx8000_EepromSendCommand( pdx, RegValue );

    return PLX_STATUS_OK;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromReadByOffset_16
 *
 * Description:  Read a 16-bit value from the EEPROM at a specified offset
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromReadByOffset_16(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U16 *pValue
    )
{
    U32 Value_32;
    PLX_STATUS status;


    // Clear return data
    *pValue = 0;

    // Get 32-bit value
    status = Plx8000_EepromReadByOffset( pdx, (offset & ~0x3), &Value_32 );
    if (status != PLX_STATUS_OK)
    {
        return status;
    }

    // Return desired 16-bit portion
    if (offset & 0x3)
    {
        *pValue = (U16)(Value_32 >> 16);
    }
    else
    {
        *pValue = (U16)Value_32;
    }

    return PLX_STATUS_OK;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromWriteByOffset_16
 *
 * Description:  Write a 16-bit value to the EEPROM at a specified offset
 *
 ******************************************************************************/
PLX_STATUS
Plx8000_EepromWriteByOffset_16(
    DEVICE_EXTENSION *pdx,
    U32 offset,
    U16 value
    )
{
    U32 Value_32;
    PLX_STATUS status;


    // Get current 32-bit value
    status = Plx8000_EepromReadByOffset( pdx, (offset & ~0x3), &Value_32 );
    if (status != PLX_STATUS_OK)
    {
        return status;
    }

    // Insert new 16-bit value in correct location
    if (offset & 0x3)
    {
        Value_32 = ((U32)value << 16) | (Value_32 & 0xFFFF);
    }
    else
    {
        Value_32 = ((U32)value) | (Value_32 & 0xFFFF0000);
    }

    // Update EEPROM
    return Plx8000_EepromWriteByOffset( pdx, (offset & ~0x3), Value_32 );
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromWaitIdle
 *
 * Description:  Wait until the EEPROM access is idle
 *
 ******************************************************************************/
BOOLEAN
Plx8000_EepromWaitIdle(
    DEVICE_EXTENSION *pdx
    )
{
    U16 OffsetCtrl;
    U32 Timeout;
    U32 RegValue;
    U32 RegCmd;


    // Get EEPROM control register offset
    OffsetCtrl = Plx8000_EepromGetCtrlOffset( pdx );

    // Verify access is supported
    if (OffsetCtrl == 0x0)
    {
        return 0;
    }

    // Get EEPROM control register
    RegCmd = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

    // Clear command field [15:13]
    RegCmd &= ~(7 << 13);

    // Clear the EepRdy bit [24]
    RegCmd &= ~(1 << 24);

    // Clear the EepWrStatus bits[30:28]
    RegCmd &= ~(7 << 28);

    // Check if there is initial CRC error reported ([19])
    if (RegCmd & (1 << 19))
    {
        /**********************************************************
         * In event of CRC error on power up, the error must be
         * cleared by writing '1'. In addition, a dummy EEPROM read
         * command might be needed to "unblock" the EEPROM controller
         * (mainly over I2C), along with a small delay to let it
         * complete. Without this dummy command, the 1st EEPROM read
         * command will fail.
         *********************************************************/
        (*(volatile unsigned int *)(pdx->base+OffsetCtrl) = (RegCmd | (3 << 13)));
        RegCmd &= ~(1 << 19);
        udelay( 50 );
    }

    // Prepare EEPROM write command
    RegCmd |= (5 << 13);

    // Set timeout
    Timeout = 10000;

    // Query EEPROM status until it's ready
    do
    {
        // Send command to get EEPROM status in bits [31:24]
        Plx8000_EepromSendCommand( pdx, RegCmd );

        // Get EEPROM control register
        RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

        // Check EEPROM read (bit 24) & write ([30:28]) status bits
        if ( ((RegValue & (1 << 24)) == 0) &&
             ((RegValue & (7 << 28)) == 0) )
        {
            return 1;
        }

        // Decrement timeout
        Timeout--;
    }
    while (Timeout);

    return 0;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromSendCommand
 *
 * Description:  Send a command to the EEPROM and wait until it has completed
 *
 ******************************************************************************/
BOOLEAN
Plx8000_EepromSendCommand(
    DEVICE_EXTENSION *pdx,
    U32 command
    )
{
    U16 OffsetCtrl;
    U32 Timeout;
    U32 RegValue;


    // Get EEPROM control register offset
    OffsetCtrl = Plx8000_EepromGetCtrlOffset( pdx );

    // Verify access is supported
    if (OffsetCtrl == 0x0)
    {
        return 0;
    }

    // Send EEPROM command
    (*(volatile unsigned int *)(pdx->base+OffsetCtrl) = (command));

    /***************************************************************
     * For Capella-1, ~10us delay is needed after issuing a command
     * to allow the chip's EEPROM output pins to respond. This
     * should only be required for PCI access mode due to speed.
     * The method is to perform multiple register reads (~1-2us each).
     **************************************************************/
    if ( (pdx->Key.PlxFamily == PLX_FAMILY_CAPELLA_1) &&
         (pdx->Key.ApiMode == PLX_API_MODE_PCI) )
    {
        for (Timeout = 0; Timeout < 200; Timeout++)
        {
            RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));
        }
    }

    // Setup timeout counter
    Timeout = 100000;

    // Wait for command to complete
    do
    {
        // Get EEPROM control register
        RegValue = (*(volatile unsigned int *)(pdx->base+OffsetCtrl));

        // EEPROM command is complete if status [19:18] is 0 or 2 (with CRC error)
        if ((RegValue & (1 << 18)) == 0)
        {
            return 1;
        }

        // Decrement timeout
        Timeout--;
    }
    while (Timeout);

    return 0;
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromComputeNextCrc
 *
 * Description:  Updates the CRC based on the next EEPROM value
 *
 ******************************************************************************/
VOID
Plx8000_EepromComputeNextCrc(
    U32 *pCrc,
    U32 NextEepromValue
    )
{
    U16 i;
    U32 XorValue;


    // Step through each bit of the CRC
    for( i = 0; i < 32; ++i )
    {
        // Shift the CRC, XOR'ing in the constant as required
        XorValue = ((*pCrc ^ (NextEepromValue << i)) & ((U32)1 << 31));

        if (XorValue)
        {
            XorValue = 0xDB710641;
        }
        else
        {
            XorValue = 0;
        }

        // XOR to update the CRC
        *pCrc = (*pCrc << 1) ^ XorValue;
    }
}




/******************************************************************************
 *
 * Function   :  Plx8000_EepromGetCtrlOffset
 *
 * Description:  Returns the EEPROM control register absolute offset (0=error)
 *
 ******************************************************************************/
U16
Plx8000_EepromGetCtrlOffset(
    DEVICE_EXTENSION *pdx
    )
{
    U16 OffsetCtrl;


    // Most PLX chips use 260h in port 0
    OffsetCtrl = 0x260;

    // Mira requires special cases
    if (pdx->Key.PlxFamily == PLX_FAMILY_MIRA)
    {
        // In Legacy mode (EP only), EEPROM offset moves
        if (pdx->Key.DeviceMode == PLX_PORT_LEGACY_ENDPOINT)
        {
            OffsetCtrl = 0x1260;
        }
        else
        {
            // In Enhanced mode, EEPROM access through USB EP is not supported
            if (pdx->Key.PlxPort == PLX_FLAG_PORT_PCIE_TO_USB)
            {
                OffsetCtrl = 0x0;
            }
        }
    }

    return OffsetCtrl;
}
# 1043 "/loongson/ejtag-debug/bin/Eep_8000.c"
unsigned char regs[] = {
0x5A,0x00,
9*6,0x00,
0x77,0x00,0x80,0x04,0x34,0x30,
0x77,0x00,0x00,0x04,0x34,0x30,
0x3a,0xC0,0x08,0x00,0xF0,0xFF,
0x0F,0xC3,0x00,0x00,0x00,0x00,
0x6D,0xC3,0x01,0x00,0x00,0x00,

/*virt*/
0x0F,0x03,0x00,0x00,0x00,0x00,
0x35,0x00,0x08,0x00,0xF0,0xFF,
0x61,0x03,0x08,0x00,0xF0,0xFF,
0x65,0x03,0x00,0x00,0x00,0x80,
};



int readeeprom()
{
 int i;
 DEVICE_EXTENSION *pdx = &Plx;
 unsigned int val;
 PLX_STATUS ret;
 for(i=0;i<0x100;i+=4)
        {
            ret = Plx8000_EepromReadByOffset( pdx, i, &val );
     if (ret != PLX_STATUS_OK)
  {
    printf("ret=%d\n", ret);
    break;
  }
    if ((i&0xf) == 0) printf("\n%04x: ", i);
     printf("%08x ",val);
 }
 printf("\n");
 return 0;

}

int writeeeprom()
{
 int i;
 DEVICE_EXTENSION *pdx = &Plx;
 unsigned int val;
 PLX_STATUS ret;
 for(i=0;i<sizeof(regs);i+=4)
        {
            ret = Plx8000_EepromWriteByOffset( pdx, i, *(unsigned int *)(regs + i) );
     if (ret != PLX_STATUS_OK)
  {
    printf("ret=%d\n", ret);
    break;
  }
 }
 return 0;

}

int mymain()
{
 writeeeprom();
 readeeprom();
}
